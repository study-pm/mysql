# Reference

- [Основные команды](#основные-команды)
  - [Работа с базами данных](#работа-с-базами-данных)
    - [Показать БД](#показать-бд)
    - [Создание БД](#создание-бд)
    - [Установка БД](#установка-бд)
    - [Удаление БД](#удаление-бд)
  - [Работа с таблицами](#работа-с-таблицами)
    - [Показать таблицы](#показать-таблицы)
    - [Создание таблицы](#создание-таблицы)
    - [Показать структуру](#показать-структуру)
    - [Переименование таблицы](#переименование-таблицы)
    - [Полное удаление данных (очистка таблицы)](#полное-удаление-данных-очистка-таблицы)
    - [Удаление таблицы](#удаление-таблицы)
  - [Работа с полями/столбцами](#работа-с-полямистолбцами)
    - [Показать столбцы (колонки)](#показать-столбцы-колонки)
    - [Добавление столбцов/полей](#добавление-столбцовполей)
    - [Изменение столбцов/полей](#изменение-столбцовполей)
      - [Изменение значения по умолчанию: `ALTER COLUMN`](#изменение-значения-по-умолчанию-alter-column)
      - [Изменение столбца с переименованием: `CHANGE COLUMN`](#изменение-столбца-с-переименованием-change-column)
      - [Изменение типа столбца без переименования: `MODIFY COLUMN`](#изменение-типа-столбца-без-переименования-modify-column)
    - [Удаление столбцов/полей](#удаление-столбцовполей)
  - [Работа с внешними ключами](#работа-с-внешними-ключами)
  - [Работа с индексами](#работа-с-индексами)
    - [Отображение индексов](#отображение-индексов)
    - [Добавление индекса](#добавление-индекса)
    - [Удаление индекса](#удаление-индекса)
- [Типы данных](#типы-данных)
  - [Символьные типы](#символьные-типы)
  - [Числовые типы](#числовые-типы)
  - [Типы для работы с датой и временем](#типы-для-работы-с-датой-и-временем)
  - [Составные типы](#составные-типы)
  - [Бинарные типы](#бинарные-типы)
- [Атрибуты столбцов и таблиц](#атрибуты-столбцов-и-таблиц)
  - [`PRIMARY KEY`](#primary-key)
  - [`AUTO_INCREMENT`](#auto_increment)
  - [`UNIQUE`](#unique)
  - [`NULL` и `NOT NULL`](#null-и-not-null)
  - [`DEFAULT`](#default)
  - [`CHECK`](#check)
  - [Оператор `CONSTRAINT`. Установка имени ограничений](#оператор-constraint-установка-имени-ограничений)
- [Внешние ключи `FOREIGN KEY`](#внешние-ключи-foreign-key)
  - [`ON DELETE` и `ON UPDATE`](#on-delete-и-on-update)
  - [Каскадное удаление](#каскадное-удаление)
  - [Установка `NULL`](#установка-null)
- [Изменение таблиц и столбцов](#изменение-таблиц-и-столбцов)
  - [Добавление нового столбца](#добавление-нового-столбца)
  - [Удаление столбца](#удаление-столбца)
  - [Изменение значения по умолчанию](#изменение-значения-по-умолчанию)


## Основные команды

### Работа с базами данных

#### Показать БД

```sql
SHOW DATABASES;
```

#### Создание БД

```sql
CREATE DATABASE <имя_базы_даных>;
CREATE DATABASE [IF NOT EXISTS] <имя_базы_даных>;
```

#### Установка БД

```sql
USE имя_базы_данных
```

#### Удаление БД

```sql
DROP DATABASE <имя_базы_даных>;
DROP DATABASE [IF EXISTS] <имя_базы_даных>;
```

### Работа с таблицами

#### Показать таблицы

```sql
SHOW TABLES;
```

#### Создание таблицы

```sql
CREATE TABLE название_таблицы
(название_столбца1 тип_данных атрибуты_столбца1,
 название_столбца2 тип_данных атрибуты_столбца2,
 ................................................
 название_столбцаN тип_данных атрибуты_столбцаN,
 атрибуты_уровня_таблицы
)
```

#### Показать структуру

```sql
DESCRIBE <название_таблицы>
```

#### Переименование таблицы

```sql
RENAME TABLE <старое_название> TO <новое_название>, <name1> TO <name2>, ...;
```

Or:

```sql
ALTER TABLE <старое_название> RENAME <новое_название>;
```

#### Полное удаление данных (очистка таблицы)

```sql
TRUNCATE TABLE <название_таблицы>;
```

#### Удаление таблицы

```sql
DROP TABLE <название_таблицы>;
```

### Работа с полями/столбцами

#### Показать столбцы (колонки)

```sql
SHOW COLUMNS FROM <название_таблицы>
```

#### Добавление столбцов/полей

`ADD COLUMN` or simply `ADD`:

```sql
ALTER TABLE <table_name> 
    ADD <column1_properties> [FIRST | AFTER],
    ADD <column2_properties> [FIRST | AFTER],
    ...
    ;
```

```sql
ALTER TABLE ctrana ADD id_c INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY FIRST;
```

#### Изменение столбцов/полей
Базовый синтаксис:

```sql
ALTER TABLE <название_таблицы> 
    ADD <название_столбца тип_данных_столбца [атрибуты_столбца]>, 
    DROP COLUMN <название_столбца>,
    MODIFY COLUMN <название_столбца тип_данных_столбца [атрибуты_столбца]>,
    ALTER COLUMN <название_столбца> SET DEFAULT <значение_по_умолчанию>,
    ADD [CONSTRAINT] <определение_ограничения>,
    DROP [CONSTRAINT] <имя_ограничения>
;
```

##### Изменение значения по умолчанию: `ALTER COLUMN`
`ALTER` is used to set or remove the default value for a column. Example:
```sql
ALTER TABLE MyTable ALTER COLUMN foo SET DEFAULT 'bar';
ALTER TABLE MyTable ALTER COLUMN foo DROP DEFAULT;
```

##### Изменение столбца с переименованием: `CHANGE COLUMN`
`CHANGE` is used to rename a column, change its datatype, or move it within the schema. Example:
```sql
ALTER TABLE MyTable CHANGE COLUMN foo bar VARCHAR(32) NOT NULL FIRST;
ALTER TABLE MyTable CHANGE COLUMN foo bar VARCHAR(32) NOT NULL AFTER baz;
```

##### Изменение типа столбца без переименования: `MODIFY COLUMN`
Used to do everything CHANGE COLUMN can, but without renaming the column. Example:
```sql
ALTER TABLE MyTable MODIFY COLUMN foo VARCHAR(32) NOT NULL AFTER baz;
```

#### Удаление столбцов/полей

```sql
ALTER TABLE <table_name> DROP COLUMN <column1_name>, <column2_name>, ...;
```

### Работа с внешними ключами





### Работа с индексами

#### Отображение индексов
```sql
SHOW INDEX FROM <имя_вашей_таблицы>;
```

```sql
SHOW INDEXES FROM <название_таблицы>
```

#### Добавление индекса
```sql
ALTER TABLE <название_таблицы> ADD [UNIQUE] INDEX (<название_столбца> [ASC | DESC])
```

```sql
CREATE [UNIQUE] INDEX <index_name> ON <table_name> (<column_name [ASC | DESC]>,... )
```

#### Удаление индекса
```sql
DROP INDEX <название_индекса> ON <название таблицы>
```

## Типы данных

### Символьные типы

- **`CHAR`**: представляет строку фиксированной длины.

    Длина хранимой строки указывается в скобках, например, `CHAR(10)` — строка из десяти символов. И если в таблицу в данный столбец сохраняется строка из 6 символов (то есть меньше установленной длины в 10 символов), то строка дополняется 4 пробелами и в итоге все равно будет занимать 10 символов

    Тип `CHAR` может хранить до 255 байт.

- **`VARCHAR`**: представляет строку переменной длины.

    Длина хранимой строки также указыватся в скобках, например, `VARCHAR(10)`. Однако в отличие от `CHAR` хранимая строка будет занимать именно столько места, сколько необходимо. Например, если определенная длина в 10 символов, но в столбец сохраняется строка в 6 символов, то хранимая строка так и будет занимать 6 символов плюс дополнительный байт, который хранит длину строки.

    Всего тип `VARCHAR` может хранить до 65535 байт.

Начиная с MySQL 5.6 типы `CHAR` и `VARCHAR` по умолчанию используют кодировку UTF-8, которая позволяет использовать до 3 байт для хранения символа в зависимости от языка (для многих европейских языков по 1 байту на символ, для ряда восточно-европейских и ближневосточных — 2 байта, а для китайского, японского, корейского — по 3 байта на символ).

Ряд дополнительных типов данных представляют текст неопределенной длины:

- **`TINYTEXT`**: представляет текст длиной до 255 байт.

- **`TEXT`**: представляет текст длиной до 65 КБ.

- **`MEDIUMTEXT`**: представляет текст длиной до 16 МБ

- **`LONGTEXT`**: представляет текст длиной до 4 ГБ

### Числовые типы

- **`TINYINT`**: представляет целые числа от -128 до 127, занимает 1 байт

- **`BOOL`**: фактически не представляет отдельный тип, а является лишь псевдонимом для типа `TINYINT(1)` и может хранить два значения 0 и 1. Однако данный тип может также в качестве значения принимать встроенные константы `TRUE` (представляет число 1) и `FALSE` (предоставляет число 0).

    Также имеет псевдоним `BOOLEAN`.

- **`TINYINT UNSIGNED`**: представляет целые числа от 0 до 255, занимает 1 байт

- **`SMALLINT`**: представляет целые числа от -32768 до 32767, занимает 2 байтa

- **`SMALLINT UNSIGNED`**: представляет целые числа от 0 до 65535, занимает 2 байтa

- **`MEDIUMINT`**: представляет целые числа от -8388608 до 8388607, занимает 3 байта

- **`MEDIUMINT UNSIGNED`**: представляет целые числа от 0 до 16777215, занимает 3 байта

- **`INT`**: представляет целые числа от -2147483648 до 2147483647, занимает 4 байта

- **`INT UNSIGNED`**: представляет целые числа от 0 до 4294967295, занимает 4 байта

- **`BIGINT`**: представляет целые числа от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807, занимает 8 байт

- **`BIGINT UNSIGNED`**: представляет целые числа от 0 до 18 446 744 073 709 551 615, занимает 8 байт

- **`DECIMAL`**: хранит числа с фиксированной точностью. Данный тип может принимать два параметра `precision` и `scale`: `DECIMAL(precision, scale)`.

    Параметр `precision` представляет максимальное количество цифр, которые может хранить число. Это значение должно находиться в диапазоне от 1 до 65.

    Параметр `scale` представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра `precision`. По умолчанию оно равно 0.

    Например, в определении следующего столбца:

    ```sql
    salary DECIMAL(5,2)
    ```

    Число 5 — `precision`, а число 2 — `scale`, поэтому данный столбец может хранить значения из диапазона от -999.99 до 999.99.

    Размер данных в байтах для `DECIMAL` зависит от хранимого значения.

    Данный тип также имеет псевдонимы `NUMERIC`, `DEC`, `FIXED`.

- **`FLOAT`**: хранит дробные числа с плавающей точкой одинарной точности от -3.4028 * 1038 до 3.4028 * 1038, занимает 4 байта

    Может принимать форму `FLOAT(M,D)`, где `M` — общее количество цифр, а `D` — количество цифр после запятой

- **`DOUBLE`**: хранит дробные числа с плавающей точкой двойной точности от -1.7976 * 10308 до 1.7976 * 10308, занимает 8 байт. Также может принимать форму `DOUBLE(M,D)`, где `M` — общее количество цифр, а `D` — количество цифр после запятой.

Данный тип также имеет псевдонимы `REAL` и `DOUBLE PRECISION`, которые можно использовать вместо `DOUBLE`.

### Типы для работы с датой и временем

- **`DATE`**: хранит даты с 1 января 1000 года до 31 деабря 9999 года (c "1000-01-01" до "9999-12-31"). По умолчанию для хранения используется формат *yyyy-mm-dd*. Занимает 3 байта.

- **`TIME`**: хранит время от -838:59:59 до 838:59:59. По умолчанию для хранения времени применяется формат "hh:mm:ss". Занимает 3 байта.

- **`DATETIME`**: объединяет время и дату, диапазон дат и времени - с 1 января 1000 года по 31 декабря 9999 года (с "1000-01-01 00:00:00" до "9999-12-31 23:59:59"). Для хранения по умолчанию используется формат "yyyy-mm-dd hh:mm:ss". Занимает 8 байт

- **`TIMESTAMP`**: также хранит дату и время, но в другом диапазоне: от "1970-01-01 00:00:01" UTC до "2038-01-19 03:14:07" UTC. Занимает 4 байта

- **`YEAR`**: хранит год в виде 4 цифр. Диапазон доступных значений от 1901 до 2155. Занимает 1 байт.

Тип `Date` может принимать даты в различных форматах, однако непосредственно для хранения в самой бд даты приводятся к формату "yyyy-mm-dd". Некоторые из принимаемых форматов:

- `yyyy-mm-dd` — 2018-05-25

- `yyyy-m-dd` — 2018-5-25

- `yy-m-dd` — 18-05-25

В таком формате двузначные числа от 00 до 69 воспринимаются как даты в диапазоне 2000-2069. А числа от 70 до 99 как диапазон чисел 1970 - 1999.

- `yyyymmdd` — 20180525

- `yyyy.mm.dd` — 2018.05.25

Для времени тип `Time` использует 24-часовой формат. Он может принимать время в различных форматах:

- `hh:mi` — 3:21 (хранимое значение 03:21:00)

- `hh:mi:ss` — 19:21:34

- `hhmiss` — 192134

Примеры значений для типов `DATETIME` и `TIMESTAMP`:

- `2018-05-25` — 19:21:34
- `2018-05-25` (хранимое значение 2018-05-25 00:00:00)

### Составные типы

- **`ENUM`**: хранит одно значение из списка допустимых значений. Занимает 1-2 байта

- **`SET`**: может хранить несколько значений (до 64 значений) из некоторого списка допустимых значений. Занимает 1-8 байт.

### Бинарные типы

- **`TINYBLOB`**: хранит бинарные данные в виде строки длиной до 255 байт.

- **`BLOB`**: хранит бинарные данные в виде строки длиной до 65 КБ.

- **`MEDIUMBLOB`**: хранит бинарные данные в виде строки длиной до 16 МБ

- **`LONGBLOB`**: хранит бинарные данные в виде строки длиной до 4 ГБ

## Атрибуты столбцов и таблиц
https://metanit.com/sql/mysql/2.4.php

### `PRIMARY KEY`

Атрибут **`PRIMARY KEY`** задает первичный ключ таблицы.

```sql
USE productsdb;

CREATE TABLE Customers
(
    Id INT PRIMARY KEY,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20)
);
```

Первичный ключ уникально идентифицирует строку в таблице. В качестве первичного ключа необязательно должны выступать столбцы с типом `int`, они могут представлять любой другой тип.

Установка первичного ключа на уровне таблицы:

```sql
USE productsdb;
CREATE TABLE Customers
(
    Id INT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20),
    PRIMARY KEY(Id)
);
```

Первичный ключ может быть составным. Такой ключ использовать сразу несколько столбцов, чтобы уникально идентифицировать строку в таблице. Например:

```sql
CREATE TABLE OrderLines
(
    OrderId INT,
    ProductId INT,
    Quantity INT,
    Price MONEY,
    PRIMARY KEY(OrderId, ProductId)
)
```

Здесь поля `OrderId` и `ProductId` вместе выступают как составной первичный ключ. То есть в таблице `OrderLines` не может быть двух строк, где для обоих из этих полей одновременно были бы одни и те же значения.

### `AUTO_INCREMENT`
Атрибут **`AUTO_INCREMENT**` позволяет указать, что значение столбца будет автоматически увеличиваться при добавлении новой строки. Данный атрибут работает для столбцов, которые представляют целочисленный тип или числа с плавающей точкой.

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20)
);
```

В данном случае значение столбца `Id` каждой новой добавленной строки будет увеличиваться на единицу.

### `UNIQUE`
Атрибут **`UNIQUE`** указывает, что столбец может хранить только уникальные значения.

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20),
    Phone VARCHAR(13) UNIQUE
);
```

В данном случае столбец `Phone`, который представляет телефон клиента, может хранить только уникальные значения. И мы не сможем добавить в таблицу две строки, у которых значения для этого столбца будет совпадать.

Также мы можем определить этот атрибут на уровне таблицы:

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20),
    Email VARCHAR(30),
    Phone VARCHAR(20),
    UNIQUE(Email, Phone)
);
```

### `NULL` и `NOT NULL`
Чтобы указать, может ли столбец принимать значение `NULL`, при определении столбца ему можно задать атрибут **`NULL`** или **`NOT NULL`**. Если этот атрибут явным образом не будет использован, то по умолчанию столбец будет допускать значение `NULL`. Исключением является тот случай, когда столбец выступает в роли первичного ключа — в этом случае по умолчанию столбец имеет значение `NOT NULL`.

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) NULL,
    Phone VARCHAR(20) NULL
);
```

В данном случае столбец `Age` по умолчанию будет иметь атрибут `NULL`.

### `DEFAULT`
Атрибут **`DEFAULT`** определяет значение по умолчанию для столбца. Если при добавлении данных для столбца не будет предусмотрено значение, то для него будет использоваться значение по умолчанию.

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT DEFAULT 18,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) NOT NULL UNIQUE,
    Phone VARCHAR(20) NOT NULL UNIQUE
);
```

Здесь столбец `Age` в качестве значения по умолчанию имеет число 18.

### `CHECK`
Атрибут **`CHECK`** задает ограничение для диапазона значений, которые могут храниться в столбце. Для этого после `CHECK` указывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. Например, возраст клиентов не может быть меньше 0 или больше 100:

```sql
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT DEFAULT 18 CHECK(Age >0 AND Age < 100),
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) CHECK(Email !=''),
    Phone VARCHAR(20) CHECK(Phone !='')
);
```

Кроме проверки возраста здесь также проверяется, что столбцы `Email` и `Phone` не могут иметь пустую строку в качестве значения (пустая строка не эквивалентна значению `NULL`).

Для соединения условий используется ключевое слово `AND`. Условия можно задать в виде операций сравнения больше (`>`), меньше (`<`), не равно (`!=`).

Также `CHECK` можно использовать на уровне таблицы:

```sql
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT DEFAULT 18,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20),
    CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))
);
```

### Оператор `CONSTRAINT`. Установка имени ограничений
С помощью ключевого слова **`CONSTRAINT`** можно задать имя для ограничений. Они указываются после ключевого слова `CONSTRAINT` перед атрибутами на уровне таблицы:

```sql
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20) NOT NULL,
    CONSTRAINT customers_pk PRIMARY KEY(Id),
    CONSTRAINT customer_phone_uq UNIQUE(Phone),
    CONSTRAINT customer_age_chk CHECK(Age >0 AND Age<100)
);
```

В данном случае ограничение для `PRIMARY KEY` называется `customers_pk`, для `UNIQUE` — `customer_phone_uq`, а для `CHECK` — `customer_age_chk`. Смысл установки имен ограничений заключается в том, что впоследствии через эти имена мы сможем управлять ограничениями — удалять или изменять их.

Установить имя можно для ограничений `PRIMARY KEY`, `CHECK`, `UNIQUE`, а также `FOREIGN KEY`, который рассматриватся далее.

## Внешние ключи `FOREIGN KEY`

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.

Общий синтаксис установки внешнего ключа на уровне таблицы:
```sql
[CONSTRAINT имя_ограничения]
FOREIGN KEY (столбец1, столбец2, ... столбецN)
REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
[ON DELETE действие]
[ON UPDATE действие]
```

Для создания ограничения внешнего ключа после **`FOREIGN KEY`** указывается столбец таблицы, который будет представляет внешний ключ. А после ключевого слова **`REFERENCES`** указывается имя связанной таблицы, а затем в скобках имя связанного столбца, на который будет указывать внешний ключ. После выражения **`REFERENCES`** идут выражения **`ON DELETE`** и **`ON UPDATE`**, которые задают действие при удалении и обновлении строки из главной таблицы соответственно.

Например, определим две таблицы и свяжем их посредством внешнего ключа:
```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Phone VARCHAR(20) NOT NULL UNIQUE
);

CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
);
```

В данном случае определены таблицы `Customers` и `Orders`. `Customers` является главной и представляет клиента. `Orders` является зависимой и представляет заказ, сделанный клиентом. Таблица `Orders` через столбец `CustomerId` связана с таблицей `Customers` и ее столбцом `Id`. То есть столбец `CustomerId` является внешним ключом, который указывает на столбец `Id` из таблицы `Customers`.

С помощью оператора **`CONSTRAINT`** можно задать имя для ограничения внешнего ключа:
```sql
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    CONSTRAINT orders_custonmers_fk
    FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
);
```

### `ON DELETE` и `ON UPDATE`
С помощью выражений **`ON DELETE`** и **`ON UPDATE`** можно установить действия, которые выполняются соответственно при удалении и изменении связанной строки из главной таблицы. В качестве действия могут использоваться следующие опции:

- **`CASCADE`**: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.

- **`SET NULL`**: при удалении или обновлении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение **`NULL`**. (В этом случае столбец внешнего ключа должен поддерживать установку `NULL`)

- **`RESTRICT`**: отклоняет удаление или изменение строк в главной таблице при наличии связанных строк в зависимой таблице.

- **`NO ACTION`**: то же самое, что и `RESTRICT`.

- **`SET DEFAULT`**: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты `DEFAULT`. Несмотря на то, что данная опция в принципе доступна, однако движок InnoDB не поддерживает данное выражение.

### Каскадное удаление
Каскадное удаление позволяет при удалении строки из главной таблицы автоматически удалить все связанные строки из зависимой таблицы. Для этого применяется опция **`CASCADE`**:

```sql
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE CASCADE
);
```
Подобным образом работает и выражение **`ON UPDATE CASCADE`**. При изменении значения первичного ключа автоматически изменится значение связанного с ним внешнего ключа. Однако поскольку первичные ключи изменяются очень редко, да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, то на практике выражение `ON UPDATE` используется редко.

### Установка `NULL`
При установки для внешнего ключа опции **`SET NULL`** необходимо, чтобы столбец внешнего ключа допускал значение `NULL`:
```sql
CREATE TABLE Orders
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
);
```

## Изменение таблиц и столбцов
Если таблица уже была ранее создана, и ее необходимо изменить, то для этого применяется команда **`ALTER TABLE`**. Ее сокращенный формальный синтаксис:
```sql
ALTER TABLE название_таблицы
{ ADD название_столбца тип_данных_столбца [атрибуты_столбца] |
  DROP COLUMN название_столбца |
  MODIFY COLUMN название_столбца тип_данных_столбца [атрибуты_столбца] |
  ALTER COLUMN название_столбца SET DEFAULT значение_по_умолчанию |
  ADD [CONSTRAINT] определение_ограничения |
  DROP [CONSTRAINT] имя_ограничения}
```
Вообще данная команда поддерживает гораздо больше опций и возможностей. Все их можно посмотреть в документации. Рассмотрим лишь основные сценарии, с которыми мы можем столкнуться.

### Добавление нового столбца
Добавим в таблицу `Customers` новый столбец `Address`:
```sql
ALTER TABLE Customers
ADD Address VARCHAR(50) NULL;
```
В данном случае столбец `Address` имеет тип `VARCHAR` и для него определен атрибут `NULL`.

### Удаление столбца
Удалим столбец `Address` из таблицы `Customers`:
```sql
ALTER TABLE Customers
DROP COLUMN Address;
```

### Изменение значения по умолчанию
Установим в таблице `Customers` для столбца `Age` значение по умолчанию `22`:
```sql
ALTER TABLE Customers
ALTER COLUMN Age SET DEFAULT 22;
```
