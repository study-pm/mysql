# Reference

- [Основные команды](#основные-команды)
  - [Работа с базами данных](#работа-с-базами-данных)
    - [Показать БД](#показать-бд)
    - [Создание БД](#создание-бд)
    - [Установка БД](#установка-бд)
    - [Удаление БД](#удаление-бд)
  - [Работа с таблицами](#работа-с-таблицами)
    - [Показать таблицы](#показать-таблицы)
    - [Создание таблицы](#создание-таблицы)
    - [Переименование таблицы](#переименование-таблицы)
    - [Полное удаление данных (очистка таблицы)](#полное-удаление-данных-очистка-таблицы)
    - [Удаление таблицы](#удаление-таблицы)
- [Типы данных](#типы-данных)
  - [Символьные типы](#символьные-типы)
  - [Числовые типы](#числовые-типы)
  - [Типы для работы с датой и временем](#типы-для-работы-с-датой-и-временем)
  - [Составные типы](#составные-типы)
  - [Бинарные типы](#бинарные-типы)
- [Атрибуты столбцов и таблиц](#атрибуты-столбцов-и-таблиц)
  - [`PRIMARY KEY`](#primary-key)
  - [`AUTO_INCREMENT`](#auto_increment)
  - [`UNIQUE`](#unique)
  - [`NULL` и `NOT NULL`](#null-и-not-null)
  - [`DEFAULT`](#default)
  - [`CHECK`](#check)
- [Изменение данных](#изменение-данных)


## Основные команды

### Работа с базами данных

#### Показать БД

```sql
SHOW DATABASES;
```

#### Создание БД

```sql
CREATE DATABASE <имя_базы_даных>;
CREATE DATABASE [IF NOT EXISTS] <имя_базы_даных>;
```

#### Установка БД

```sql
USE имя_базы_данных
```

#### Удаление БД

```sql
DROP DATABASE <имя_базы_даных>;
DROP DATABASE [IF EXISTS] <имя_базы_даных>;
```

### Работа с таблицами

#### Показать таблицы

```sql
SHOW TABLES;
```

#### Создание таблицы

```sql
CREATE TABLE название_таблицы
(название_столбца1 тип_данных атрибуты_столбца1,
 название_столбца2 тип_данных атрибуты_столбца2,
 ................................................
 название_столбцаN тип_данных атрибуты_столбцаN,
 атрибуты_уровня_таблицы
)
```

#### Переименование таблицы

```sql
RENAME TABLE <старое_название> TO <новое_название>;
```

#### Полное удаление данных (очистка таблицы)

```sql
TRUNCATE TABLE <название_таблицы>;
```

#### Удаление таблицы

```sql
DROP TABLE <название_таблицы>;
```

## Типы данных

### Символьные типы

- **`CHAR`**: представляет строку фиксированной длины.

    Длина хранимой строки указывается в скобках, например, `CHAR(10)` — строка из десяти символов. И если в таблицу в данный столбец сохраняется строка из 6 символов (то есть меньше установленной длины в 10 символов), то строка дополняется 4 пробелами и в итоге все равно будет занимать 10 символов

    Тип `CHAR` может хранить до 255 байт.

- **`VARCHAR`**: представляет строку переменной длины.

    Длина хранимой строки также указыватся в скобках, например, `VARCHAR(10)`. Однако в отличие от `CHAR` хранимая строка будет занимать именно столько места, сколько необходимо. Например, если определенная длина в 10 символов, но в столбец сохраняется строка в 6 символов, то хранимая строка так и будет занимать 6 символов плюс дополнительный байт, который хранит длину строки.

    Всего тип `VARCHAR` может хранить до 65535 байт.

Начиная с MySQL 5.6 типы `CHAR` и `VARCHAR` по умолчанию используют кодировку UTF-8, которая позволяет использовать до 3 байт для хранения символа в зависимости от языка (для многих европейских языков по 1 байту на символ, для ряда восточно-европейских и ближневосточных — 2 байта, а для китайского, японского, корейского — по 3 байта на символ).

Ряд дополнительных типов данных представляют текст неопределенной длины:

- **`TINYTEXT`**: представляет текст длиной до 255 байт.

- **`TEXT`**: представляет текст длиной до 65 КБ.

- **`MEDIUMTEXT`**: представляет текст длиной до 16 МБ

- **`LONGTEXT`**: представляет текст длиной до 4 ГБ

### Числовые типы

- **`TINYINT`**: представляет целые числа от -128 до 127, занимает 1 байт

- **`BOOL`**: фактически не представляет отдельный тип, а является лишь псевдонимом для типа `TINYINT(1)` и может хранить два значения 0 и 1. Однако данный тип может также в качестве значения принимать встроенные константы `TRUE` (представляет число 1) и `FALSE` (предоставляет число 0).

    Также имеет псевдоним `BOOLEAN`.

- **`TINYINT UNSIGNED`**: представляет целые числа от 0 до 255, занимает 1 байт

- **`SMALLINT`**: представляет целые числа от -32768 до 32767, занимает 2 байтa

- **`SMALLINT UNSIGNED`**: представляет целые числа от 0 до 65535, занимает 2 байтa

- **`MEDIUMINT`**: представляет целые числа от -8388608 до 8388607, занимает 3 байта

- **`MEDIUMINT UNSIGNED`**: представляет целые числа от 0 до 16777215, занимает 3 байта

- **`INT`**: представляет целые числа от -2147483648 до 2147483647, занимает 4 байта

- **`INT UNSIGNED`**: представляет целые числа от 0 до 4294967295, занимает 4 байта

- **`BIGINT`**: представляет целые числа от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807, занимает 8 байт

- **`BIGINT UNSIGNED`**: представляет целые числа от 0 до 18 446 744 073 709 551 615, занимает 8 байт

- **`DECIMAL`**: хранит числа с фиксированной точностью. Данный тип может принимать два параметра `precision` и `scale`: `DECIMAL(precision, scale)`.

    Параметр `precision` представляет максимальное количество цифр, которые может хранить число. Это значение должно находиться в диапазоне от 1 до 65.

    Параметр `scale` представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра `precision`. По умолчанию оно равно 0.

    Например, в определении следующего столбца:

    ```sql
    salary DECIMAL(5,2)
    ```

    Число 5 — `precision`, а число 2 — `scale`, поэтому данный столбец может хранить значения из диапазона от -999.99 до 999.99.

    Размер данных в байтах для `DECIMAL` зависит от хранимого значения.

    Данный тип также имеет псевдонимы `NUMERIC`, `DEC`, `FIXED`.

- **`FLOAT`**: хранит дробные числа с плавающей точкой одинарной точности от -3.4028 * 1038 до 3.4028 * 1038, занимает 4 байта

    Может принимать форму `FLOAT(M,D)`, где `M` — общее количество цифр, а `D` — количество цифр после запятой

- **`DOUBLE`**: хранит дробные числа с плавающей точкой двойной точности от -1.7976 * 10308 до 1.7976 * 10308, занимает 8 байт. Также может принимать форму `DOUBLE(M,D)`, где `M` — общее количество цифр, а `D` — количество цифр после запятой.

Данный тип также имеет псевдонимы `REAL` и `DOUBLE PRECISION`, которые можно использовать вместо `DOUBLE`.

### Типы для работы с датой и временем

- **`DATE`**: хранит даты с 1 января 1000 года до 31 деабря 9999 года (c "1000-01-01" до "9999-12-31"). По умолчанию для хранения используется формат *yyyy-mm-dd*. Занимает 3 байта.

- **`TIME`**: хранит время от -838:59:59 до 838:59:59. По умолчанию для хранения времени применяется формат "hh:mm:ss". Занимает 3 байта.

- **`DATETIME`**: объединяет время и дату, диапазон дат и времени - с 1 января 1000 года по 31 декабря 9999 года (с "1000-01-01 00:00:00" до "9999-12-31 23:59:59"). Для хранения по умолчанию используется формат "yyyy-mm-dd hh:mm:ss". Занимает 8 байт

- **`TIMESTAMP`**: также хранит дату и время, но в другом диапазоне: от "1970-01-01 00:00:01" UTC до "2038-01-19 03:14:07" UTC. Занимает 4 байта

- **`YEAR`**: хранит год в виде 4 цифр. Диапазон доступных значений от 1901 до 2155. Занимает 1 байт.

Тип `Date` может принимать даты в различных форматах, однако непосредственно для хранения в самой бд даты приводятся к формату "yyyy-mm-dd". Некоторые из принимаемых форматов:

- `yyyy-mm-dd` — 2018-05-25

- `yyyy-m-dd` — 2018-5-25

- `yy-m-dd` — 18-05-25

В таком формате двузначные числа от 00 до 69 воспринимаются как даты в диапазоне 2000-2069. А числа от 70 до 99 как диапазон чисел 1970 - 1999.

- `yyyymmdd` — 20180525

- `yyyy.mm.dd` — 2018.05.25

Для времени тип `Time` использует 24-часовой формат. Он может принимать время в различных форматах:

- `hh:mi` — 3:21 (хранимое значение 03:21:00)

- `hh:mi:ss` — 19:21:34

- `hhmiss` — 192134

Примеры значений для типов `DATETIME` и `TIMESTAMP`:

- `2018-05-25` — 19:21:34
- `2018-05-25` (хранимое значение 2018-05-25 00:00:00)

### Составные типы

- **`ENUM`**: хранит одно значение из списка допустимых значений. Занимает 1-2 байта

- **`SET`**: может хранить несколько значений (до 64 значений) из некоторого списка допустимых значений. Занимает 1-8 байт.

### Бинарные типы

- **`TINYBLOB`**: хранит бинарные данные в виде строки длиной до 255 байт.

- **`BLOB`**: хранит бинарные данные в виде строки длиной до 65 КБ.

- **`MEDIUMBLOB`**: хранит бинарные данные в виде строки длиной до 16 МБ

- **`LONGBLOB`**: хранит бинарные данные в виде строки длиной до 4 ГБ

## Атрибуты столбцов и таблиц
https://metanit.com/sql/mysql/2.4.php

### `PRIMARY KEY`

Атрибут **`PRIMARY KEY`** задает первичный ключ таблицы.

```sql
USE productsdb;

CREATE TABLE Customers
(
    Id INT PRIMARY KEY,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20)
);
```

Первичный ключ уникально идентифицирует строку в таблице. В качестве первичного ключа необязательно должны выступать столбцы с типом `int`, они могут представлять любой другой тип.

Установка первичного ключа на уровне таблицы:

```sql
USE productsdb;
CREATE TABLE Customers
(
    Id INT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20),
    PRIMARY KEY(Id)
);
```

Первичный ключ может быть составным. Такой ключ использовать сразу несколько столбцов, чтобы уникально идентифицировать строку в таблице. Например:

```sql
CREATE TABLE OrderLines
(
    OrderId INT,
    ProductId INT,
    Quantity INT,
    Price MONEY,
    PRIMARY KEY(OrderId, ProductId)
)
```

Здесь поля `OrderId` и `ProductId` вместе выступают как составной первичный ключ. То есть в таблице `OrderLines` не может быть двух строк, где для обоих из этих полей одновременно были бы одни и те же значения.

### `AUTO_INCREMENT`
Атрибут **`AUTO_INCREMENT**` позволяет указать, что значение столбца будет автоматически увеличиваться при добавлении новой строки. Данный атрибут работает для столбцов, которые представляют целочисленный тип или числа с плавающей точкой.

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20)
);
```

В данном случае значение столбца `Id` каждой новой добавленной строки будет увеличиваться на единицу.

### `UNIQUE`
Атрибут **`UNIQUE`** указывает, что столбец может хранить только уникальные значения.

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20),
    Phone VARCHAR(13) UNIQUE
);
```

В данном случае столбец `Phone`, который представляет телефон клиента, может хранить только уникальные значения. И мы не сможем добавить в таблицу две строки, у которых значения для этого столбца будет совпадать.

Также мы можем определить этот атрибут на уровне таблицы:

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20),
    LastName VARCHAR(20),
    Email VARCHAR(30),
    Phone VARCHAR(20),
    UNIQUE(Email, Phone)
);
```

### `NULL` и `NOT NULL`
Чтобы указать, может ли столбец принимать значение `NULL`, при определении столбца ему можно задать атрибут **`NULL`** или **`NOT NULL`**. Если этот атрибут явным образом не будет использован, то по умолчанию столбец будет допускать значение `NULL`. Исключением является тот случай, когда столбец выступает в роли первичного ключа — в этом случае по умолчанию столбец имеет значение `NOT NULL`.

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) NULL,
    Phone VARCHAR(20) NULL
);
```

В данном случае столбец `Age` по умолчанию будет иметь атрибут `NULL`.

### `DEFAULT`
Атрибут **`DEFAULT`** определяет значение по умолчанию для столбца. Если при добавлении данных для столбца не будет предусмотрено значение, то для него будет использоваться значение по умолчанию.

```sql
CREATE TABLE Customers
(
    Id INT PRIMARY KEY AUTO_INCREMENT,
    Age INT DEFAULT 18,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) NOT NULL UNIQUE,
    Phone VARCHAR(20) NOT NULL UNIQUE
);
```

Здесь столбец `Age` в качестве значения по умолчанию имеет число 18.

### `CHECK`
Атрибут **`CHECK`** задает ограничение для диапазона значений, которые могут храниться в столбце. Для этого после `CHECK` указывается в скобках условие, которому должен соответствовать столбец или несколько столбцов. Например, возраст клиентов не может быть меньше 0 или больше 100:

```sql
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT DEFAULT 18 CHECK(Age >0 AND Age < 100),
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) CHECK(Email !=''),
    Phone VARCHAR(20) CHECK(Phone !='')
);
```

Кроме проверки возраста здесь также проверяется, что столбцы `Email` и `Phone` не могут иметь пустую строку в качестве значения (пустая строка не эквивалентна значению `NULL`).

Для соединения условий используется ключевое слово `AND`. Условия можно задать в виде операций сравнения больше (`>`), меньше (`<`), не равно (`!=`).

Также `CHECK` можно использовать на уровне таблицы:

```sql
CREATE TABLE Customers
(
    Id INT AUTO_INCREMENT,
    Age INT DEFAULT 18,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30),
    Phone VARCHAR(20),
    CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))
);
```

---

## Изменение данных

```sql
CREATE DATABASE productsdb;
USE productsdb;
```

```sql
CREATE TABLE customers (
    IdC INT PRIMARY KEY AUTO_INCREMENT,
    Age INT DEFAULT 18,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    Email VARCHAR(30) NOT NULL UNIQUE,
    Phone VARCHAR(20) NOT NULL UNIQUE
);
```

```sql
ALTER TABLE Customers ADD Address VARCHAR(50) NULL;
```

```sql
ALTER TABLE Customers ADD Address VARCHAR(50) NULL FIRST;
```

```sql
CREATE TABLE Orders (
IdO INT PRIMARY KEY AUTO_INCREMENT,
CustomerId INT,
CreatedAt DATE);
```

```sql
ALTER TABLE Orders ADD FOREIGN KEY(CustomerId) REFERENCES Customers(IdC);
```
